/*!
 * baffle 0.3.4 - A tiny javascript library for obfuscating and revealing text in DOM elements.
 * Copyright (c) 2016 Cam Wiegert <cam@camwiegert.com> - https://camwiegert.github.io/baffle
 * License: MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["baffle"] = factory();
	else
		root["baffle"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _baffleWithTask = __webpack_require__(1);

	var _baffleWithTask2 = _interopRequireDefault(_baffleWithTask);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	module.exports = _baffleWithTask2.default;

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	var _baffle = __webpack_require__(2);

	var _baffle2 = _interopRequireDefault(_baffle);

	var _taskQueue = __webpack_require__(5);

	var _taskQueue2 = _interopRequireDefault(_taskQueue);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var BaffleWithTask = function () {
		function BaffleWithTask(elements, options) {
			_classCallCheck(this, BaffleWithTask);

			this.baffle = (0, _baffle2.default)(elements, options);
			this.task = (0, _taskQueue2.default)();

			console.log(this.task);
			var tbaffle = this.baffle;
			var ttask = this.task;
			// bind baffle methods to *this*
			this.baffleOnce = tbaffle.once.bind(tbaffle);
			// this.await = ttask.addDelayToQueue;
			this.baffleStart = tbaffle.start.bind(tbaffle);
			this.baffleReveal = tbaffle.reveal.bind(tbaffle);
			this.baffleSet = tbaffle.set.bind(tbaffle);
			this.baffleText = tbaffle.text.bind(tbaffle);
			this.baffleStop = tbaffle.stop.bind(tbaffle);
		}

		BaffleWithTask.prototype.await = function await(delay) {
			this.task.addDelayToQueue(delay);
			return this;
		};

		BaffleWithTask.prototype.once = function once() {
			this.task.addTaskToQueue(this.baffleOnce);
			return this;
		};

		BaffleWithTask.prototype.start = function start() {
			this.task.addTaskToQueue(this.baffleStart);
			return this;
		};

		BaffleWithTask.prototype.reveal = function reveal(duration, delay) {
			var _this = this;

			if (delay) {
				this.task.addDelayToQueue(delay);
			}
			if (duration) {
				// the reveal function in baffle use another *setInterval*, so need to add
				// a delay in task
				this.task.addTaskToQueue(function (_) {
					return _this.baffleReveal(duration);
				});
				this.task.addDelayToQueue(duration * 1.2);
			} else {
				this.task.addTaskToQueue(this.baffleReveal);
			}
			return this;
		};

		BaffleWithTask.prototype.stop = function stop() {
			this.task.addTaskToQueue(this.baffleStop);
			return this;
		};

		BaffleWithTask.prototype.set = function set(options) {
			var _this2 = this;

			this.task.addTaskToQueue(function (_) {
				return _this2.baffleSet(options);
			});
			return this;
		};

		BaffleWithTask.prototype.text = function text(fn) {
			var _this3 = this;

			this.task.addTaskToQueue(function (_) {
				return _this3.baffleText(fn);
			});
			return this;
		};

		return BaffleWithTask;
	}();

	exports.default = function (elements, options) {
		return new BaffleWithTask(elements, options);
	};

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _utils = __webpack_require__(3);

	var _obfuscator = __webpack_require__(4);

	var _obfuscator2 = _interopRequireDefault(_obfuscator);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var defaults = {
	    characters: 'AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz~!@#$%^&*()-+=[]{}|;:,./<>?'.split(''),
	    speed: 50
	};

	/**
	* - Baffle -
	*
	* Provides an interface to one or many instances of
	* the Obfuscator class. This is the public-facing class.
	*
	* baffle(<elements>, [options]);
	*
	*/

	var Baffle = function () {
	    function Baffle(elements, options) {
	        _classCallCheck(this, Baffle);

	        this.options = (0, _utils.extend)(Object.create(defaults), options);
	        this.elements = (0, _utils.getElements)(elements).map(_obfuscator2.default);
	        this.running = false;
	    }

	    /**
	    * Call the write method on each Obfuscator once, using
	    * the provided characters.
	    */


	    Baffle.prototype.once = function once() {
	        var _this = this;

	        (0, _utils.each)(this.elements, function (el) {
	            return el.write(_this.options.characters);
	        });
	        this.running = true;
	        return this;
	    };

	    /**
	    * Run once() every options.speed milliseconds.
	    */


	    Baffle.prototype.start = function start() {
	        var _this2 = this;

	        clearInterval(this.interval);
	        (0, _utils.each)(this.elements, function (el) {
	            return el.init();
	        });
	        this.interval = setInterval(function () {
	            return _this2.once();
	        }, this.options.speed);
	        this.running = true;
	        return this;
	    };

	    /**
	    * Stop any running interval.
	    */


	    Baffle.prototype.stop = function stop() {
	        clearInterval(this.interval);
	        this.running = false;
	        return this;
	    };

	    /**
	    * Set any options provided in the opts object. If
	    * currently running, restart.
	    */


	    Baffle.prototype.set = function set(opts) {
	        (0, _utils.extend)(this.options, opts);
	        if (this.running) this.start();
	        return this;
	    };

	    /**
	    * Set the text in each element with the return value
	    * of function fn, which receives the current text as
	    * its only argument.
	    */


	    Baffle.prototype.text = function text(fn) {
	        var _this3 = this;

	        (0, _utils.each)(this.elements, function (el) {
	            el.text(fn(el.value));
	            if (!_this3.running) el.write();
	        });
	        return this;
	    };

	    /**
	    * Start a new interval, obfuscating fewer characters
	    * on each cycle at pace to finish within duration
	    * milliseconds. Optionally, delay by delay millseconds.
	    *
	    * Once all elements are revealed, call stop() and
	    * initialize each element.
	    */


	    Baffle.prototype.reveal = function reveal() {
	        var _this4 = this;

	        var duration = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
	        var delay = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

	        // Number of cycles in duration
	        var cycles = duration / this.options.speed || 1;

	        var run = function run() {
	            clearInterval(_this4.interval);
	            _this4.running = true;
	            _this4.interval = setInterval(function () {

	                // Get elements that haven't been fully revealed
	                var elements = _this4.elements.filter(function (el) {
	                    return !el.bitmap.every(function (bit) {
	                        return !bit;
	                    });
	                });

	                // Decay each by pace and write
	                (0, _utils.each)(elements, function (el) {
	                    var pace = Math.ceil(el.value.length / cycles);
	                    el.decay(pace).write(_this4.options.characters);
	                });

	                // If all elements are revealed, stop and init
	                if (!elements.length) {
	                    _this4.stop();
	                    (0, _utils.each)(_this4.elements, function (el) {
	                        return el.init();
	                    });
	                }
	            }, _this4.options.speed);
	        };

	        setTimeout(run, delay);
	        return this;
	    };

	    return Baffle;
	}();

	// Export a factory function so we don't need 'new'.


	exports.default = function (elements, options) {
	    return new Baffle(elements, options);
	};

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.extend = extend;
	exports.mapString = mapString;
	exports.sample = sample;
	exports.each = each;
	exports.getTruthyIndices = getTruthyIndices;
	exports.getElements = getElements;
	// Extend one object with another.
	function extend(obj, ext) {
	    for (var key in ext) {
	        if (ext.hasOwnProperty(key)) {
	            obj[key] = ext[key];
	        }
	    }
	    return obj;
	}

	// Transform each character in a string.
	function mapString(str, fn) {
	    return str.split('').map(fn).join('');
	}

	// Get a random item from an array.
	function sample(arr) {
	    return arr[Math.floor(Math.random() * arr.length)];
	}

	// Operate on each item in an array.
	function each(arr, fn) {
	    for (var i = 0, l = arr.length; i < l; i++) {
	        fn(arr[i], i);
	    }
	}

	// Get an array of the indices of truthy values in arr.
	function getTruthyIndices(arr) {
	    return arr.map(function (item, index) {
	        if (!item) return false;
	        return index;
	    }).filter(function (i) {
	        return i !== false;
	    });
	}

	// Get an array of elements with a selector, NodeList, Node, or HTMLCollection.
	function getElements(obj) {
	    if (typeof obj === 'string') return [].slice.call(document.querySelectorAll(obj));
	    if ([NodeList, HTMLCollection].some(function (collection) {
	        return obj instanceof collection;
	    })) return [].slice.call(obj);
	    if (obj.nodeType) return [obj];
	    return obj;
	}

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});

	var _utils = __webpack_require__(3);

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	* - Obfuscator -
	*
	* Provides a low-level interface to obfuscate and reveal
	* a string based on its corresponding bitmap.
	*
	* ('hello', [0,1,0,1,0], '*') => '*e*l*o'
	*
	*/
	var Obfuscator = function () {
	    function Obfuscator(str) {
	        _classCallCheck(this, Obfuscator);

	        this.value = str;
	        this.init();
	    }

	    /**
	    * Set the bitmap to an array of 1s, with length equal to this.value.
	    */


	    Obfuscator.prototype.init = function init() {
	        this.bitmap = this.value.split('').map(function () {
	            return 1;
	        });
	        return this;
	    };

	    /**
	    * Create and return a string by mapping each character in
	    * this.value to either one of the provided characters randomly
	    * or to itself, depending on whether the corresponding bitmap
	    * index is truthy.
	    */


	    Obfuscator.prototype.render = function render() {
	        var _this = this;

	        var characters = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
	        var exclude = arguments.length <= 1 || arguments[1] === undefined ? [' '] : arguments[1];


	        // If no characters are provided, return the raw value.
	        if (!characters.length) return this.value;
	        return (0, _utils.mapString)(this.value, function (char, index) {

	            // Skip any characters that are passed as exclude.
	            if (exclude.indexOf(char) > -1) return char;

	            /**
	            * If corresponding bitmap index is truthy, return
	            * a randomly chosen character from characters, else
	            * return this character.
	            */
	            return _this.bitmap[index] ? (0, _utils.sample)(characters) : char;
	        });
	    };

	    /**
	    * Set count of the truthy indices in this.bitmap to 0,
	    * chosen randomly.
	    */


	    Obfuscator.prototype.decay = function decay() {
	        var count = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];

	        while (count--) {
	            var on = (0, _utils.getTruthyIndices)(this.bitmap);
	            this.bitmap[(0, _utils.sample)(on)] = 0;
	        }
	        return this;
	    };

	    /**
	    * Change this.value to a new string and reset this.bitmap
	    * to match.
	    */


	    Obfuscator.prototype.text = function text() {
	        var str = arguments.length <= 0 || arguments[0] === undefined ? this.value : arguments[0];

	        this.value = str;
	        this.init();
	        return this;
	    };

	    return Obfuscator;
	}();

	/**
	* - ObfuscatorElement -
	*
	* Extends Obfuscator to be able to wrap a DOM element and
	* update its textContent.
	*
	* (<p>Hi Mom!</p>).write('*~•+') => <p>•~ *+~•</p>
	*
	*/


	var ObfuscatorElement = function (_Obfuscator) {
	    _inherits(ObfuscatorElement, _Obfuscator);

	    function ObfuscatorElement(element) {
	        _classCallCheck(this, ObfuscatorElement);

	        var _this2 = _possibleConstructorReturn(this, _Obfuscator.call(this, element.textContent));

	        _this2.element = element;
	        return _this2;
	    }

	    ObfuscatorElement.prototype.write = function write(chars) {
	        this.element.textContent = this.render(chars);
	        return this;
	    };

	    return ObfuscatorElement;
	}(Obfuscator);

	// Export a factory function so we don't need 'new'.


	exports.default = function (element) {
	    return new ObfuscatorElement(element);
	};

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
		value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/* 
		it's used to store tasks in a queue;

		add a task 
			- addTaskToQueue(fn)
		add some delay 
			- addDelayToQueue(delay)
		execute task after delay
			- addTaskWithDelay(fn, delay)
	*/
	var taskQueue = function () {
		// checkDelay is in *ms*
		function taskQueue() {
			var checkDelay = arguments.length <= 0 || arguments[0] === undefined ? 50 : arguments[0];

			_classCallCheck(this, taskQueue);

			// bindings
			this.executeTask = this.executeTask.bind(this);
			this.isTaskQueueEmpty = this.isTaskQueueEmpty.bind(this);
			this.getTaskInQueue = this.getTaskInQueue.bind(this);
			this.addDelayToQueue = this.addDelayToQueue.bind(this);
			this.addTaskToQueue = this.addTaskToQueue.bind(this);
			this.clearTasksInQueue = this.clearTasksInQueue.bind(this);
			this.clearQueueImmediately = this.clearQueueImmediately.bind(this);
			// set executeTask every 'checkDelay'ms
			this.interval = setInterval(this.executeTask, checkDelay);
			// store checkDelay
			this.checkDelay = checkDelay;
			// used to store tasks;
			this.queue = [];
		}

		taskQueue.prototype.executeTask = function executeTask() {
			// if there is a delayTime 
			if (this.timeDelayTo) {
				if (new Date().getTime() < this.timeDelayTo) {
					return;
				} else {
					// current time is bigger than timeDelayTo
					// clear delay time
					this.timeDelayTo = null;
				}
			}
			// task is empty, return
			var task = this.getTaskInQueue();
			if (!task) {
				return;
			}

			// task is delay
			if (task.type === 'delay') {
				// set timeDalayTo according to current time
				this.timeDelayTo = new Date().getTime() + task.delayTime;
				return;
			}

			// if is task, execute it;
			if (task.type === 'task') {
				task.taskFunc();
			}
		};

		taskQueue.prototype.isTaskQueueEmpty = function isTaskQueueEmpty() {
			return !this.queue.length;
		};

		// get a task from the queue; if queue is empty, return *null*


		taskQueue.prototype.getTaskInQueue = function getTaskInQueue() {
			return this.queue.shift() || null;
		};

		// add a 'clear queue' task in queue;


		taskQueue.prototype.clearTasksInQueue = function clearTasksInQueue() {
			this.queue.push({
				type: 'clear-queue'
			});
		};

		taskQueue.prototype.runImmediately = function runImmediately(fn) {
			fn();
			return this;
		};
		// clear a queue immediately 


		taskQueue.prototype.clearQueueImmediately = function clearQueueImmediately() {
			this.queue = [];
			this.timeDelayTo = null;
		};

		taskQueue.prototype.addDelayToQueue = function addDelayToQueue(delay) {
			this.queue.push({
				type: 'delay',
				delayTime: delay
			});
			return this;
		};

		taskQueue.prototype.addTaskToQueue = function addTaskToQueue(task) {
			this.queue.push({
				type: 'task',
				taskFunc: task
			});
			return this;
		};

		taskQueue.prototype.addTaskWithDelay = function addTaskWithDelay(task, delay) {
			this.addDelayToQueue(delay);
			this.addTaskToQueue(task);
		};

		return taskQueue;
	}();

	exports.default = function (delay) {
		return new taskQueue(delay);
	};

/***/ }
/******/ ])
});
;